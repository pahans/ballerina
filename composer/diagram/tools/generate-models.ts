import { BallerinaAST } from "@ballerina/ast-model";
import bbeASTs from '../resources/bbe-asts.json';
import { stripIndent } from 'common-tags';
import * as fs from 'fs';

const modelInfo: any = {}

bbeASTs.forEach(bbe => {
    findModelInfo(bbe.ast);
});


const interfaces = Object.keys(modelInfo).map(key => {
    return `export ${genInterfaceCode(key, modelInfo[key])}`;
})
fs.writeFileSync('./models.d.ts', stripIndent`
    // This is an autogenerated file. Do not edit. Run 'npm run gen-models' to generate.
    export as namespace Ballerina;
    ${interfaces.join('\n')}
`);

function findModelInfo(node: BallerinaAST) {
    if (!modelInfo[node.kind]) {
        modelInfo[node.kind] = {
            __count: 0,
        }
    }
    const model = modelInfo[node.kind];
    model.__count++;

    Object.keys(node).forEach(key => {
        const value = (node as any)[key];

        if(model[key] === undefined) {
            model[key] = {
                __count: 0,
                type: {}
            }
        }
        const property = model[key];
        property.__count++

        if (value.kind) {
            property.type[value.kind] = true;
            findModelInfo(value);
            return;
        }

        if (Array.isArray(value)) {
            let types: any = {};
            value.forEach(valueEl => {
                if (valueEl.kind) {
                    types[valueEl.kind] = true;
                    findModelInfo(valueEl);
                    return;
                }

                const primitiveType = typeof valueEl;
                types[primitiveType] = true;
            });
            if (property.elementTypes) {
                Object.assign(types, property.elementTypes);
            }
            property.elementTypes = types;
            return;
        }

        const primitiveType = typeof value;
        property.type[primitiveType] = true;
    })
}

function genInterfaceCode(kind: string, model: any) {
    return stripIndent`
        interface ${kind} {
            ${getPropertyCode(model).join("\n            ")}
        }
    `;
}

function getPropertyCode(model: any) {
    const code : any[] = [];

    Object.keys(model).forEach(key => {
        if (key.startsWith("__")) {
            return;
        }

        const property = model[key];

        let type = 'any';
        const typesFound: any = [];
        Object.keys(property.type).forEach(key => {
            typesFound.push(key);
        });
        if (typesFound.length > 0) {
            type = typesFound.join('|');
        }

        if (property.elementTypes) {
            const elementTypesFound: any = [];
            Object.keys(property.elementTypes).forEach(key => {
                elementTypesFound.push(key)
            });
            if (elementTypesFound.length > 0) {
                type = `(${elementTypesFound.join('|')})[]`;
            }
        }

        const optional = model.__count > property.__count ? '?' : '';
        code.push(`${key}${optional}: ${type}`);
    });

    return code;
}
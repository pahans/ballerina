// This is an autogenerated file. Do not edit. Run 'npm run gen-models' to generate.
    export as namespace Ballerina;
    export interface CompilationUnit {
    ws: (object)[]
    position: object
    id: string
    name: string
    topLevelNodes: (Import|Endpoint|Service|Variable|Function|TypeDefinition)[]
    kind: string
}
export interface Import {
    ws: (object)[]
    position: object
    id: string
    orgName: Identifier
    alias: Identifier
    packageName: (Identifier)[]
    kind: string
    packageVersion: Identifier
}
export interface Identifier {
    id: string
    literal: boolean
    value: string
    kind: string
    valueWithBar: string
    position?: object
}
export interface TypeDefinition {
    ws: (object)[]
    position: object
    id: string
    name: Identifier
    deprecatedAttachments: any
    annotationAttachments: any
    typeNode: ObjectType
    kind: string
    public: boolean
    private: boolean
    native: boolean
    final: boolean
    attached: boolean
    lambda: boolean
    parallel: boolean
    connector: boolean
    deprecated: boolean
    readonly: boolean
    function_final: boolean
    interface: boolean
    defaultable_checked: boolean
    defaultable: boolean
    record: boolean
    compensate: boolean
    abstract: boolean
    optional: boolean
    testable: boolean
    isObjectType: boolean
    isAbstractKeywordAvailable?: boolean
}
export interface ObjectType {
    position: object
    id: string
    symbolType: (string)[]
    functions: (Function)[]
    fields: (Variable)[]
    grouped: boolean
    nullable: boolean
    kind: string
    typeReferences: any
    initFunction?: Function
}
export interface Function {
    ws?: (object)[]
    position: object
    id: string
    workers: (Worker)[]
    returnTypeAnnotationAttachments: any
    name: Identifier
    annotationAttachments: (AnnotationAttachment)[]
    returnTypeNode: ValueType
    receiver?: Variable
    defaultableParameters: any
    deprecatedAttachments: any
    endpointNodes: any
    parameters: (Variable)[]
    kind: string
    public: boolean
    private: boolean
    native: boolean
    final: boolean
    attached: boolean
    lambda: boolean
    parallel: boolean
    connector: boolean
    deprecated: boolean
    readonly: boolean
    function_final: boolean
    interface: boolean
    defaultable_checked: boolean
    defaultable: boolean
    record: boolean
    compensate: boolean
    abstract: boolean
    optional: boolean
    testable: boolean
    hasReturns?: boolean
    allParams: (Variable)[]
    noVisibleReceiver?: boolean
    body?: Block
    isConstructor?: boolean
    objectOuterFunction?: boolean
    objectOuterFunctionTypeName?: Identifier
    restParameters?: Variable
}
export interface ValueType {
    ws?: (object)[]
    position?: object
    id: string
    symbolType?: (string)[]
    typeKind: string
    grouped: boolean
    nullable: boolean
    kind: string
    withParantheses?: boolean
}
export interface Variable {
    position: object
    id: string
    symbolType?: (string)[]
    safeAssignment: boolean
    deprecatedAttachments: any
    annotationAttachments: any
    name: Identifier
    kind: string
    public: boolean
    private: boolean
    native: boolean
    final: boolean
    attached: boolean
    lambda: boolean
    parallel: boolean
    connector: boolean
    deprecated: boolean
    readonly: boolean
    function_final: boolean
    interface: boolean
    defaultable_checked: boolean
    defaultable: boolean
    record: boolean
    compensate: boolean
    abstract: boolean
    optional: boolean
    testable: boolean
    ws?: (object)[]
    typeNode?: ValueType|UserDefinedType|FunctionType|ArrayType|ConstrainedType|BuiltInRefType
    inObject?: boolean
    endWithSemicolon?: boolean
    noVisibleName?: boolean
    initialExpression?: TypeInitExpr|Lambda|ArrowExpr|ArrayLiteralExpr|Literal|CheckExpr|SimpleVariableRef|Invocation|AwaitExpr|RecordLiteralExpr
    arrowExprParam?: boolean
    global?: boolean
    rest?: boolean
    serviceEndpoint?: boolean
}
export interface Block {
    id: string
    statements: (VariableDef|ExpressionStatement|Assignment|CompoundAssignment|While|WorkerReceive|Return|WorkerSend|Match|If)[]
    kind: string
    position?: object
}
export interface Return {
    ws: (object)[]
    position: object
    id: string
    expression: BinaryExpr|SimpleVariableRef
    kind: string
}
export interface BinaryExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    rightExpression: SimpleVariableRef|Literal|Invocation
    operatorKind: string
    kind: string
    leftExpression: BinaryExpr|SimpleVariableRef|FieldBasedAccessExpr|Literal
}
export interface SimpleVariableRef {
    ws: (object)[]
    position: object
    id: string
    symbolType?: (string)[]
    variableName: Identifier
    packageAlias: Identifier
    kind: string
    isExpression?: boolean
}
export interface Literal {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    value: string
    unescapedValue?: string
    originalValue: string
    kind: string
    isExpression?: boolean
}
export interface UserDefinedType {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    packageAlias: Identifier
    grouped: boolean
    public: boolean
    private: boolean
    native: boolean
    final: boolean
    attached: boolean
    lambda: boolean
    parallel: boolean
    connector: boolean
    deprecated: boolean
    readonly: boolean
    function_final: boolean
    interface: boolean
    defaultable_checked: boolean
    defaultable: boolean
    record: boolean
    compensate: boolean
    abstract: boolean
    optional: boolean
    testable: boolean
    typeName: Identifier
    nullable: boolean
    kind: string
}
export interface If {
    ws: (object)[]
    position: object
    id: string
    body: Block
    condition: BracedTupleExpr
    kind: string
}
export interface Assignment {
    ws: (object)[]
    position: object
    id: string
    variable: FieldBasedAccessExpr|IndexBasedAccessExpr|SimpleVariableRef
    expression: SimpleVariableRef|IndexBasedAccessExpr|Literal|ArrayLiteralExpr|AwaitExpr
    declaredWithVar: boolean
    kind: string
}
export interface FieldBasedAccessExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    fieldName: Identifier
    expression: SimpleVariableRef
    kind: string
}
export interface BracedTupleExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    expressions: (Literal|BinaryExpr)[]
    kind: string
}
export interface VariableDef {
    ws: (object)[]
    position: object
    id: string
    variable: Variable
    kind: string
}
export interface TypeInitExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    expressions: (Literal)[]
    type: UserDefinedType
    kind: string
    hasParantheses: boolean
    typeName: Identifier
    isExpression: boolean
}
export interface ExpressionStatement {
    ws: (object)[]
    position: object
    id: string
    expression: Invocation|MatchExpression
    kind: string
}
export interface Invocation {
    ws: (object)[]
    position: object
    id: string
    symbolType: any
    invocationType?: string
    iterableOperation: boolean
    argumentExpressions: (Literal|NamedArgsExpr|SimpleVariableRef|IndexBasedAccessExpr|FieldBasedAccessExpr|Invocation|UnaryExpr|BinaryExpr)[]
    async: boolean
    packageAlias: Identifier
    actionInvocation: boolean
    name: Identifier
    expression?: SimpleVariableRef
    kind: string
    isExpression?: boolean
}
export interface FunctionType {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    returnKeywordExists: boolean
    params: (Variable)[]
    grouped: boolean
    returnTypeNode: ValueType
    nullable: boolean
    kind: string
    hasReturn: boolean
}
export interface Lambda {
    position: object
    id: string
    symbolType: (string)[]
    functionNode: Function
    kind: string
    isExpression: boolean
}
export interface ArrowExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    parameters: (Variable)[]
    expression: BinaryExpr
    kind: string
    hasParantheses: boolean
    isExpression: boolean
}
export interface ArrayType {
    ws?: (object)[]
    position?: object
    id: string
    symbolType: (string)[]
    dimensions: number
    elementType: ValueType
    grouped: boolean
    sizes: (number)[]
    nullable: boolean
    kind: string
    dimensionAsString?: string
    isRestParam?: boolean
}
export interface ArrayLiteralExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    expressions: (Literal|ArrayLiteralExpr)[]
    kind: string
    isExpression?: boolean
}
export interface AnnotationAttachment {
    ws: (object)[]
    position: object
    id: string
    expression?: RecordLiteralExpr
    annotationName: Identifier
    packageAlias: Identifier
    kind: string
}
export interface RecordLiteralExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    keyValuePairs: (RecordLiteralKeyValue)[]
    kind: string
    isExpression?: boolean
}
export interface RecordLiteralKeyValue {
    ws: (object)[]
    id: string
    value: Literal
    key: SimpleVariableRef|Literal
    kind: string
}
export interface IndexBasedAccessExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    expression: SimpleVariableRef|IndexBasedAccessExpr
    index: SimpleVariableRef|Literal
    kind: string
}
export interface CompoundAssignment {
    ws: (object)[]
    position: object
    id: string
    expression: Literal
    operatorKind: string
    variable: SimpleVariableRef
    kind: string
    compoundOperator: string
}
export interface CheckExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    operatorKind: string
    kind: string
    expression: TypeConversionExpr
    isExpression: boolean
}
export interface TypeConversionExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    expression: SimpleVariableRef|IndexBasedAccessExpr
    typeNode: ValueType|BuiltInRefType
    kind: string
}
export interface UnaryExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    operatorKind: string
    kind: string
    expression: SimpleVariableRef|IndexBasedAccessExpr|Invocation
}
export interface Endpoint {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    configurationExpression: RecordLiteralExpr
    name: Identifier
    annotationAttachments: any
    kind: string
    endPointType: UserDefinedType
    public: boolean
    private: boolean
    native: boolean
    final: boolean
    attached: boolean
    lambda: boolean
    parallel: boolean
    connector: boolean
    deprecated: boolean
    readonly: boolean
    function_final: boolean
    interface: boolean
    defaultable_checked: boolean
    defaultable: boolean
    record: boolean
    compensate: boolean
    abstract: boolean
    optional: boolean
    testable: boolean
}
export interface ConstrainedType {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    grouped: boolean
    nullable: boolean
    constraint: ValueType|UnionTypeNode
    type: BuiltInRefType
    kind: string
}
export interface BuiltInRefType {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    grouped: boolean
    typeKind: string
    nullable: boolean
    kind: string
}
export interface UnionTypeNode {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    memberTypeNodes: (UserDefinedType)[]
    grouped: boolean
    nullable: boolean
    kind: string
}
export interface AwaitExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    expression: SimpleVariableRef
    kind: string
    isExpression?: boolean
}
export interface Match {
    ws: (object)[]
    position: object
    id: string
    expression: SimpleVariableRef
    kind: string
    patternClauses: (MatchPatternClause)[]
}
export interface MatchPatternClause {
    ws: (object)[]
    position: object
    id: string
    variableNode: Variable
    statement: Block
    kind: string
    withCurlies: boolean
}
export interface Worker {
    ws: (object)[]
    position: object
    id: string
    workers: any
    returnTypeAnnotationAttachments: any
    name: Identifier
    annotationAttachments: any
    returnTypeNode: ValueType
    defaultableParameters: any
    deprecatedAttachments: any
    endpointNodes: any
    body: Block
    parameters: (Variable)[]
    kind: string
    public: boolean
    private: boolean
    native: boolean
    final: boolean
    attached: boolean
    lambda: boolean
    parallel: boolean
    connector: boolean
    deprecated: boolean
    readonly: boolean
    function_final: boolean
    interface: boolean
    defaultable_checked: boolean
    defaultable: boolean
    record: boolean
    compensate: boolean
    abstract: boolean
    optional: boolean
    testable: boolean
}
export interface WorkerSend {
    ws: (object)[]
    position: object
    id: string
    workerName: Identifier
    expression: SimpleVariableRef
    forkJoinedSend: boolean
    kind: string
}
export interface WorkerReceive {
    ws: (object)[]
    position: object
    id: string
    expression: SimpleVariableRef
    workerName: Identifier
    kind: string
}
export interface While {
    ws: (object)[]
    position: object
    id: string
    condition: BracedTupleExpr
    kind: string
    body: Block
}
export interface Service {
    ws: (object)[]
    position: object
    id: string
    annotationAttachments: any
    initFunction: Function
    endpointNodes: any
    namespaceDeclarations: any
    boundEndpoints: (SimpleVariableRef)[]
    resources: (Resource)[]
    deprecatedAttachments: any
    variables: any
    name: Identifier
    kind: string
    isServiceTypeUnavailable: boolean
}
export interface Resource {
    ws: (object)[]
    position: object
    id: string
    workers: any
    returnTypeAnnotationAttachments: any
    name: Identifier
    annotationAttachments: any
    returnTypeNode: ValueType
    defaultableParameters: any
    deprecatedAttachments: any
    endpointNodes: any
    body: Block
    parameters: (Variable)[]
    kind: string
    public: boolean
    private: boolean
    native: boolean
    final: boolean
    attached: boolean
    lambda: boolean
    parallel: boolean
    connector: boolean
    deprecated: boolean
    readonly: boolean
    function_final: boolean
    interface: boolean
    defaultable_checked: boolean
    defaultable: boolean
    record: boolean
    compensate: boolean
    abstract: boolean
    optional: boolean
    testable: boolean
}
export interface MatchExpression {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    expression: Invocation
    kind: string
    patternClauses: (MatchExpressionPatternClause)[]
}
export interface MatchExpressionPatternClause {
    ws: (object)[]
    position: object
    id: string
    variableNode: Variable
    kind: string
    statement: Invocation
}
export interface NamedArgsExpr {
    ws: (object)[]
    position: object
    id: string
    symbolType: (string)[]
    expression: SimpleVariableRef
    name: Identifier
    kind: string
}
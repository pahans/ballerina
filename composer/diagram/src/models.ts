// This is an autogenerated file. Do not edit. Run 'npm run gen-models' to generate.
// tslint:disable:ban-types
export interface CompilationUnit {
  ws: object[];
  position: object;
  id: string;
  name: string;
  topLevelNodes: Array<
    Import | Function | Variable | Xmlns | Endpoint | Service | TypeDefinition
  >;
  kind: string;
}
export interface Import {
  ws?: object[];
  position: object;
  id: string;
  orgName: Identifier;
  alias: Identifier;
  packageName: Identifier[];
  kind: string;
  packageVersion: Identifier;
  userDefinedAlias?: boolean;
  isInternal?: boolean;
}
export interface Identifier {
  id: string;
  literal: boolean;
  value: string;
  kind: string;
  valueWithBar: string;
  position?: object;
}
export interface TypeDefinition {
  ws: object[];
  position: object;
  id: string;
  name: Identifier;
  deprecatedAttachments: any;
  annotationAttachments: any;
  typeNode: ObjectType | RecordType | UnionTypeNode | FiniteTypeNode;
  kind: string;
  public: boolean;
  private: boolean;
  native: boolean;
  final: boolean;
  attached: boolean;
  lambda: boolean;
  parallel: boolean;
  connector: boolean;
  deprecated: boolean;
  readonly: boolean;
  function_final: boolean;
  interface: boolean;
  defaultable_checked: boolean;
  defaultable: boolean;
  record: boolean;
  compensate: boolean;
  abstract: boolean;
  optional: boolean;
  testable: boolean;
  isObjectType?: boolean;
  isAbstractKeywordAvailable?: boolean;
  isRecordType?: boolean;
  isRecordKeywordAvailable?: boolean;
  markdownDocumentationAttachment?: MarkdownDocumentation;
}
export interface ObjectType {
  position: object;
  id: string;
  symbolType: string[];
  functions: Function[];
  fields: Variable[];
  grouped: boolean;
  nullable: boolean;
  kind: string;
  typeReferences: UserDefinedType[];
  initFunction?: Function;
}
export interface Function {
  ws?: object[];
  position: object;
  id: string;
  workers: Worker[];
  returnTypeAnnotationAttachments: AnnotationAttachment[];
  name: Identifier;
  annotationAttachments: AnnotationAttachment[];
  returnTypeNode:
    | ValueType
    | TupleTypeNode
    | UnionTypeNode
    | FunctionType
    | ArrayType
    | ConstrainedType
    | UserDefinedType
    | BuiltInRefType;
  receiver?: Variable;
  defaultableParameters: VariableDef[];
  deprecatedAttachments: any;
  endpointNodes: Endpoint[];
  parameters: Array<Variable | VariableDef>;
  kind: string;
  public: boolean;
  private: boolean;
  native: boolean;
  final: boolean;
  attached: boolean;
  lambda: boolean;
  parallel: boolean;
  connector: boolean;
  deprecated: boolean;
  readonly: boolean;
  function_final: boolean;
  interface: boolean;
  defaultable_checked: boolean;
  defaultable: boolean;
  record: boolean;
  compensate: boolean;
  abstract: boolean;
  optional: boolean;
  testable: boolean;
  hasReturns?: boolean;
  allParams: Array<Variable | VariableDef>;
  noVisibleReceiver?: boolean;
  body?: Block;
  isConstructor?: boolean;
  objectOuterFunction?: boolean;
  objectOuterFunctionTypeName?: Identifier;
  restParameters?: Variable;
  hasRestParams?: boolean;
  markdownDocumentationAttachment?: MarkdownDocumentation;
  isStreamAction?: boolean;
}
export interface ValueType {
  ws?: object[];
  position?: object;
  id: string;
  symbolType?: string[];
  typeKind: string;
  grouped: boolean;
  nullable: boolean;
  kind: string;
  withParantheses?: boolean;
  emptyParantheses?: boolean;
  nullableOperatorAvailable?: boolean;
}
export interface Variable {
  position: object;
  id: string;
  symbolType?: string[];
  safeAssignment: boolean;
  deprecatedAttachments: any;
  annotationAttachments: AnnotationAttachment[];
  name: Identifier;
  kind: string;
  public: boolean;
  private: boolean;
  native: boolean;
  final: boolean;
  attached: boolean;
  lambda: boolean;
  parallel: boolean;
  connector: boolean;
  deprecated: boolean;
  readonly: boolean;
  function_final: boolean;
  interface: boolean;
  defaultable_checked: boolean;
  defaultable: boolean;
  record: boolean;
  compensate: boolean;
  abstract: boolean;
  optional: boolean;
  testable: boolean;
  ws?: object[];
  typeNode?:
    | ValueType
    | UserDefinedType
    | FunctionType
    | ArrayType
    | ConstrainedType
    | BuiltInRefType
    | TupleTypeNode
    | UnionTypeNode;
  inObject?: boolean;
  endWithSemicolon?: boolean;
  noVisibleName?: boolean;
  initialExpression?:
    | TypeInitExpr
    | Lambda
    | ArrowExpr
    | ArrayLiteralExpr
    | Literal
    | CheckExpr
    | SimpleVariableRef
    | Invocation
    | AwaitExpr
    | RecordLiteralExpr
    | XmlElementLiteral
    | Table
    | FieldBasedAccessExpr
    | TypeConversionExpr
    | BinaryExpr
    | MatchExpression
    | ElvisExpr
    | IndexBasedAccessExpr
    | StringTemplateLiteral
    | UnaryExpr
    | TableQueryExpression
    | BracedTupleExpr
    | XmlAttributeAccessExpr
    | XmlTextLiteral
    | XmlCommentLiteral
    | XmlPiLiteral;
  arrowExprParam?: boolean;
  global?: boolean;
  rest?: boolean;
  serviceEndpoint?: boolean;
}
export interface Block {
  id: string;
  statements: Array<
    | VariableDef
    | ExpressionStatement
    | Assignment
    | CompoundAssignment
    | Xmlns
    | Match
    | Throw
    | Return
    | Transaction
    | TupleDestructure
    | Foreach
    | If
    | Lock
    | WorkerReceive
    | WorkerSend
    | While
    | Next
    | Break
    | Done
    | Try
    | Abort
    | Forever
    | Retry
    | ForkJoin
  >;
  kind: string;
  position?: object;
  ws?: object[];
  isElseBlock?: boolean;
}
export interface Return {
  ws: object[];
  position: object;
  id: string;
  expression:
    | BinaryExpr
    | SimpleVariableRef
    | Literal
    | Lambda
    | Invocation
    | FieldBasedAccessExpr
    | BracedTupleExpr
    | IndexBasedAccessExpr
    | ArrayLiteralExpr;
  kind: string;
  noExpressionAvailable?: boolean;
}
export interface BinaryExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType?: string[];
  rightExpression:
    | SimpleVariableRef
    | Literal
    | Invocation
    | CheckExpr
    | FieldBasedAccessExpr
    | BinaryExpr
    | UnaryExpr
    | IndexBasedAccessExpr
    | BracedTupleExpr
    | TypeConversionExpr;
  operatorKind: string;
  kind: string;
  leftExpression:
    | BinaryExpr
    | SimpleVariableRef
    | FieldBasedAccessExpr
    | Literal
    | Invocation
    | IndexBasedAccessExpr
    | UnaryExpr
    | BracedTupleExpr;
  isExpression?: boolean;
}
export interface SimpleVariableRef {
  ws?: object[];
  position: object;
  id: string;
  symbolType?: string[];
  variableName: Identifier;
  packageAlias?: Identifier;
  kind: string;
  isExpression?: boolean;
  inTemplateLiteral?: boolean;
}
export interface Literal {
  ws?: object[];
  position: object;
  id: string;
  symbolType?: string[];
  value: string;
  unescapedValue?: string;
  originalValue?: string;
  kind: string;
  isExpression?: boolean;
  inTemplateLiteral?: boolean;
  emptyParantheses?: boolean;
  startTemplateLiteral?: boolean;
  endTemplateLiteral?: boolean;
  lastNodeValue?: boolean;
}
export interface UserDefinedType {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  packageAlias: Identifier;
  grouped: boolean;
  typeName: Identifier;
  public: boolean;
  private: boolean;
  native: boolean;
  final: boolean;
  attached: boolean;
  lambda: boolean;
  parallel: boolean;
  connector: boolean;
  deprecated: boolean;
  readonly: boolean;
  function_final: boolean;
  interface: boolean;
  defaultable_checked: boolean;
  defaultable: boolean;
  record: boolean;
  compensate: boolean;
  abstract: boolean;
  optional: boolean;
  testable: boolean;
  nullable: boolean;
  kind: string;
  nullableOperatorAvailable?: boolean;
}
export interface If {
  ws: object[];
  position: object;
  id: string;
  body: Block;
  condition: BracedTupleExpr;
  kind: string;
  elseStatement?: Block | If;
  ladderParent?: boolean;
  isElseIfBlock?: boolean;
}
export interface Assignment {
  ws: object[];
  position: object;
  id: string;
  variable:
    | FieldBasedAccessExpr
    | IndexBasedAccessExpr
    | SimpleVariableRef
    | XmlAttributeAccessExpr;
  expression:
    | SimpleVariableRef
    | IndexBasedAccessExpr
    | Literal
    | ArrayLiteralExpr
    | AwaitExpr
    | Invocation
    | CheckExpr
    | TypeConversionExpr
    | MatchExpression
    | Lambda
    | BinaryExpr
    | RecordLiteralExpr
    | UnaryExpr
    | TypeInitExpr
    | FieldBasedAccessExpr
    | TernaryExpr
    | XmlElementLiteral;
  declaredWithVar: boolean;
  kind: string;
}
export interface FieldBasedAccessExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType?: string[];
  fieldName: Identifier;
  expression:
    | SimpleVariableRef
    | Invocation
    | FieldBasedAccessExpr
    | IndexBasedAccessExpr;
  kind: string;
  errorLifting?: boolean;
  isExpression?: boolean;
}
export interface BracedTupleExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType?: string[];
  expressions: Array<
    | BinaryExpr
    | SimpleVariableRef
    | Invocation
    | UnaryExpr
    | Literal
    | CheckExpr
    | FieldBasedAccessExpr
    | TypeConversionExpr
  >;
  kind: string;
  isExpression?: boolean;
}
export interface VariableDef {
  ws: object[];
  position: object;
  id: string;
  variable: Variable;
  kind: string;
  defaultable?: boolean;
}
export interface TypeInitExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  expressions: Array<
    SimpleVariableRef | Literal | RecordLiteralExpr | NamedArgsExpr | Invocation
  >;
  type?: UserDefinedType;
  kind: string;
  hasParantheses?: boolean;
  typeName?: Identifier;
  isExpression?: boolean;
  noExpressionAvailable?: boolean;
  noTypeAttached?: boolean;
}
export interface ExpressionStatement {
  ws: object[];
  position: object;
  id: string;
  expression: Invocation | MatchExpression;
  kind: string;
}
export interface Invocation {
  ws: object[];
  position: object;
  id: string;
  symbolType: any;
  invocationType?: string;
  iterableOperation: boolean;
  argumentExpressions: Array<
    | SimpleVariableRef
    | Literal
    | IndexBasedAccessExpr
    | RecordLiteralExpr
    | TypeConversionExpr
    | Invocation
    | NamedArgsExpr
    | FieldBasedAccessExpr
    | XmlAttributeAccessExpr
    | BinaryExpr
    | ArrayLiteralExpr
    | StringTemplateLiteral
    | UnaryExpr
    | MatchExpression
    | Lambda
    | RestArgsExpr
    | XmlElementLiteral
  >;
  packageAlias: Identifier;
  async: boolean;
  actionInvocation: boolean;
  name: Identifier;
  expression?:
    | SimpleVariableRef
    | Invocation
    | FieldBasedAccessExpr
    | IndexBasedAccessExpr;
  kind: string;
  isExpression?: boolean;
}
export interface FunctionType {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  returnKeywordExists: boolean;
  params: Variable[];
  grouped: boolean;
  returnTypeNode: ValueType | FunctionType | UserDefinedType;
  nullable: boolean;
  kind: string;
  hasReturn?: boolean;
  withParantheses?: boolean;
}
export interface Lambda {
  position: object;
  id: string;
  symbolType: string[];
  functionNode: Function;
  kind: string;
  isExpression?: boolean;
}
export interface ArrowExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  parameters: Variable[];
  expression: BinaryExpr;
  kind: string;
  hasParantheses: boolean;
  isExpression: boolean;
}
export interface ArrayType {
  ws?: object[];
  position?: object;
  id: string;
  symbolType: string[];
  dimensions: number;
  elementType: ValueType | UserDefinedType | ArrayType | BuiltInRefType;
  grouped: boolean;
  sizes: number[];
  nullable: boolean;
  kind: string;
  dimensionAsString?: string;
  isRestParam?: boolean;
}
export interface ArrayLiteralExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  expressions: Array<
    | Literal
    | RecordLiteralExpr
    | FieldBasedAccessExpr
    | ArrayLiteralExpr
    | SimpleVariableRef
    | TypeConversionExpr
  >;
  kind: string;
  isExpression?: boolean;
}
export interface AnnotationAttachment {
  ws: object[];
  position: object;
  id: string;
  expression?: RecordLiteralExpr;
  annotationName: Identifier;
  packageAlias: Identifier;
  kind: string;
}
export interface RecordLiteralExpr {
  ws: object[];
  position?: object;
  id: string;
  symbolType?: string[];
  keyValuePairs: RecordLiteralKeyValue[];
  kind: string;
  isExpression?: boolean;
}
export interface RecordLiteralKeyValue {
  ws?: object[];
  id: string;
  value:
    | Literal
    | ArrayLiteralExpr
    | RecordLiteralExpr
    | Invocation
    | BinaryExpr
    | SimpleVariableRef
    | UnaryExpr
    | FieldBasedAccessExpr;
  key: SimpleVariableRef | Literal;
  kind: string;
}
export interface IndexBasedAccessExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType?: string[];
  expression: SimpleVariableRef | IndexBasedAccessExpr | FieldBasedAccessExpr;
  index:
    | SimpleVariableRef
    | Literal
    | TypeConversionExpr
    | BinaryExpr
    | FieldBasedAccessExpr;
  kind: string;
  isExpression?: boolean;
}
export interface CompoundAssignment {
  ws: object[];
  position: object;
  id: string;
  expression: Literal | SimpleVariableRef | BinaryExpr;
  variable: SimpleVariableRef;
  operatorKind: string;
  kind: string;
  compoundOperator: string;
}
export interface CheckExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  operatorKind: string;
  kind: string;
  expression: TypeConversionExpr | Invocation | FieldBasedAccessExpr;
  isExpression?: boolean;
}
export interface TypeConversionExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  expression:
    | SimpleVariableRef
    | IndexBasedAccessExpr
    | Invocation
    | FieldBasedAccessExpr
    | XmlAttributeAccessExpr;
  typeNode:
    | ValueType
    | BuiltInRefType
    | ArrayType
    | TupleTypeNode
    | UserDefinedType;
  kind: string;
  isExpression?: boolean;
}
export interface UnaryExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  operatorKind: string;
  kind: string;
  expression:
    | SimpleVariableRef
    | IndexBasedAccessExpr
    | Invocation
    | FieldBasedAccessExpr
    | CheckExpr;
  isExpression?: boolean;
  inTemplateLiteral?: boolean;
}
export interface Endpoint {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  configurationExpression?: RecordLiteralExpr | Invocation;
  name: Identifier;
  annotationAttachments: AnnotationAttachment[];
  kind: string;
  endPointType: UserDefinedType;
  public: boolean;
  private: boolean;
  native: boolean;
  final: boolean;
  attached: boolean;
  lambda: boolean;
  parallel: boolean;
  connector: boolean;
  deprecated: boolean;
  readonly: boolean;
  function_final: boolean;
  interface: boolean;
  defaultable_checked: boolean;
  defaultable: boolean;
  record: boolean;
  compensate: boolean;
  abstract: boolean;
  optional: boolean;
  testable: boolean;
  isConfigAssignment?: boolean;
}
export interface ConstrainedType {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  grouped: boolean;
  nullable: boolean;
  constraint: ValueType | UnionTypeNode | BuiltInRefType | UserDefinedType;
  type: BuiltInRefType;
  kind: string;
}
export interface BuiltInRefType {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  grouped: boolean;
  typeKind: string;
  nullable: boolean;
  kind: string;
}
export interface UnionTypeNode {
  ws: object[];
  position?: object;
  id: string;
  symbolType: string[];
  memberTypeNodes: Array<
    UserDefinedType | ValueType | ArrayType | TupleTypeNode
  >;
  grouped: boolean;
  nullable: boolean;
  kind: string;
  withParantheses?: boolean;
}
export interface AwaitExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  expression: SimpleVariableRef;
  kind: string;
  isExpression?: boolean;
}
export interface Match {
  ws: object[];
  position: object;
  id: string;
  expression: SimpleVariableRef | BracedTupleExpr | Invocation;
  kind: string;
  patternClauses: MatchPatternClause[];
}
export interface MatchPatternClause {
  ws: object[];
  position: object;
  id: string;
  variableNode: Variable;
  statement: Block;
  kind: string;
  withCurlies?: boolean;
}
export interface Worker {
  ws: object[];
  position: object;
  id: string;
  workers: any;
  returnTypeAnnotationAttachments: any;
  name: Identifier;
  annotationAttachments: any;
  returnTypeNode?: ValueType;
  defaultableParameters: any;
  deprecatedAttachments: any;
  body: Block;
  endpointNodes: any;
  parameters: Variable[];
  kind: string;
  public: boolean;
  private: boolean;
  native: boolean;
  final: boolean;
  attached: boolean;
  lambda: boolean;
  parallel: boolean;
  connector: boolean;
  deprecated: boolean;
  readonly: boolean;
  function_final: boolean;
  interface: boolean;
  defaultable_checked: boolean;
  defaultable: boolean;
  record: boolean;
  compensate: boolean;
  abstract: boolean;
  optional: boolean;
  testable: boolean;
}
export interface WorkerSend {
  ws: object[];
  position: object;
  id: string;
  workerName: Identifier;
  expression: SimpleVariableRef | BracedTupleExpr;
  forkJoinedSend: boolean;
  kind: string;
  keyExpression?: SimpleVariableRef;
}
export interface WorkerReceive {
  ws: object[];
  position: object;
  id: string;
  expression: SimpleVariableRef;
  workerName: Identifier;
  kind: string;
  keyExpression?: SimpleVariableRef;
}
export interface While {
  ws: object[];
  position: object;
  id: string;
  condition: BracedTupleExpr;
  kind: string;
  body: Block;
}
export interface Service {
  ws: object[];
  position: object;
  id: string;
  annotationAttachments: AnnotationAttachment[];
  initFunction: Function;
  endpointNodes: any;
  namespaceDeclarations: any;
  resources: Resource[];
  boundEndpoints: SimpleVariableRef[];
  deprecatedAttachments: any;
  name: Identifier;
  variables: VariableDef[];
  kind: string;
  isServiceTypeUnavailable?: boolean;
  serviceTypeStruct?: UserDefinedType;
  anonymousEndpointBind?: RecordLiteralExpr;
  bindNotAvailable?: boolean;
}
export interface Resource {
  ws: object[];
  position: object;
  id: string;
  workers: any;
  returnTypeAnnotationAttachments: any;
  name: Identifier;
  annotationAttachments: AnnotationAttachment[];
  returnTypeNode: ValueType;
  defaultableParameters: any;
  deprecatedAttachments: any;
  body: Block;
  endpointNodes: Endpoint[];
  parameters: Variable[];
  kind: string;
  public: boolean;
  private: boolean;
  native: boolean;
  final: boolean;
  attached: boolean;
  lambda: boolean;
  parallel: boolean;
  connector: boolean;
  deprecated: boolean;
  readonly: boolean;
  function_final: boolean;
  interface: boolean;
  defaultable_checked: boolean;
  defaultable: boolean;
  record: boolean;
  compensate: boolean;
  abstract: boolean;
  optional: boolean;
  testable: boolean;
}
export interface MatchExpression {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  expression: Invocation | SimpleVariableRef | FieldBasedAccessExpr;
  kind: string;
  patternClauses: MatchExpressionPatternClause[];
  isExpression?: boolean;
}
export interface MatchExpressionPatternClause {
  ws: object[];
  position: object;
  id: string;
  variableNode: Variable;
  kind: string;
  statement:
    | Invocation
    | SimpleVariableRef
    | Literal
    | BinaryExpr
    | FieldBasedAccessExpr;
}
export interface NamedArgsExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType?: string[];
  expression: SimpleVariableRef | Literal | RecordLiteralExpr | UnaryExpr;
  name: Identifier;
  kind: string;
}
export interface TupleTypeNode {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  grouped: boolean;
  memberTypeNodes: Array<ValueType | ArrayType | UserDefinedType>;
  nullable: boolean;
  kind: string;
}
export interface Throw {
  ws: object[];
  position: object;
  id: string;
  kind: string;
  expressions: SimpleVariableRef;
}
export interface Try {
  ws: object[];
  position: object;
  id: string;
  body: Block;
  catchBlocks: Catch[];
  kind: string;
  finallyBody?: Block;
}
export interface TupleDestructure {
  ws: object[];
  position: object;
  id: string;
  expression: Invocation | CheckExpr | SimpleVariableRef;
  declaredWithVar: boolean;
  variableRefs: SimpleVariableRef[];
  kind: string;
}
export interface Catch {
  ws: object[];
  position: object;
  id: string;
  body: Block;
  parameter: Variable;
  kind: string;
}
export interface XmlElementLiteral {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  startTagName: XmlQname | SimpleVariableRef;
  attributes: XmlAttribute[];
  namespaces: string;
  content: Array<
    | Literal
    | XmlElementLiteral
    | XmlCommentLiteral
    | SimpleVariableRef
    | UnaryExpr
  >;
  endTagName?: XmlQname | SimpleVariableRef;
  kind: string;
  inTemplateLiteral?: boolean;
  root?: boolean;
  startLiteral?: string;
  isExpression?: boolean;
}
export interface XmlQname {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  localname: Identifier;
  prefix: Identifier;
  kind: string;
  inTemplateLiteral?: boolean;
}
export interface RecordType {
  position: object;
  id: string;
  symbolType: string[];
  fields: Variable[];
  grouped: boolean;
  sealed: boolean;
  nullable: boolean;
  kind: string;
  typeReferences: any;
  ws?: object[];
  restFieldType?: ValueType;
  isRestFieldAvailable?: boolean;
}
export interface RestArgsExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  expression: SimpleVariableRef;
  kind: string;
}
export interface Foreach {
  ws: object[];
  position: object;
  id: string;
  variables: SimpleVariableRef[];
  collection:
    | SimpleVariableRef
    | Invocation
    | BinaryExpr
    | FieldBasedAccessExpr;
  kind: string;
  body: Block;
  withParantheses?: boolean;
}
export interface Table {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  tableColumns: TableColumn[];
  dataRows: Array<SimpleVariableRef | RecordLiteralExpr>;
  kind: string;
  isExpression: boolean;
}
export interface MarkdownDocumentation {
  ws: object[];
  position: object;
  id: string;
  documentationLines: DocumentationDescription[];
  documentation: string;
  parameters: DocumentationParameter[];
  parameterDocumentations: string;
  kind: string;
  returnParameterDocumentation?: string;
  returnParameter?: DocumentationParameter;
}
export interface DocumentationDescription {
  ws?: object[];
  position: object;
  id: string;
  text: string;
  kind: string;
}
export interface DocumentationParameter {
  ws: object[];
  position: object;
  id: string;
  parameterDocumentation?: string;
  parameterDocumentationLines?: string[];
  parameterName?: Identifier;
  kind: string;
  returnParameterDocumentationLines?: string[];
  returnParameterDocumentation?: string;
}
export interface ElvisExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  leftExpression: SimpleVariableRef | Invocation | IndexBasedAccessExpr;
  rightExpression: Literal | SimpleVariableRef;
  kind: string;
  isExpression: boolean;
}
export interface ForkJoin {
  ws: object[];
  position: object;
  id: string;
  joinType: string;
  joinedWorkerIdentifiers: any;
  joinResultVar: Variable;
  workers: Worker[];
  joinBody: Block;
  kind: string;
  joinCount: number;
  timeOutExpression?: Literal;
  timeOutVariable?: Variable;
  timeoutBody?: Block;
}
export interface StringTemplateLiteral {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  kind: string;
  expressions: Array<
    Literal | SimpleVariableRef | UnaryExpr | FieldBasedAccessExpr
  >;
  startTemplate: string;
  isExpression?: boolean;
}
export interface Done {
  ws: object[];
  position: object;
  id: string;
  kind: string;
}
export interface Forever {
  ws: object[];
  position: object;
  id: string;
  siddhiRuntimeEnabled: boolean;
  kind: string;
  streamingQueryStatements: StreamingQuery[];
}
export interface StreamingQuery {
  ws: object[];
  position: object;
  id: string;
  streamingInput?: StreamingInput;
  streamingAction: StreamAction;
  selectClause: SelectClause;
  kind: string;
  patternClause?: PatternClause;
  joiningInput?: JoinStreamingInput;
}
export interface StreamingInput {
  position: object;
  id: string;
  windowTraversedAfterWhere: boolean;
  windowClause?: WindowClause;
  streamReference: SimpleVariableRef;
  kind: string;
  beforeStreamingCondition?: Where;
  ws?: object[];
  alias?: string;
  aliasAvailable?: boolean;
  afterStreamingCondition?: Where;
}
export interface WindowClause {
  ws: object[];
  position: object;
  id: string;
  functionInvocation: Invocation;
  kind: string;
}
export interface Where {
  ws: object[];
  position: object;
  id: string;
  expression: BinaryExpr;
  kind: string;
}
export interface StreamAction {
  ws: object[];
  position: object;
  id: string;
  invokableBody: Lambda;
  kind: string;
}
export interface SelectClause {
  ws: object[];
  position: object;
  id: string;
  selectAll: boolean;
  groupBy?: GroupBy;
  having?: Having;
  selectExpressions?: SelectExpression[];
  kind: string;
}
export interface GroupBy {
  ws: object[];
  position: object;
  id: string;
  variables: Array<SimpleVariableRef | FieldBasedAccessExpr>;
  kind: string;
}
export interface Having {
  ws: object[];
  position: object;
  id: string;
  expression: BinaryExpr;
  kind: string;
}
export interface SelectExpression {
  position: object;
  id: string;
  expression:
    | SimpleVariableRef
    | Invocation
    | FieldBasedAccessExpr
    | TernaryExpr;
  kind: string;
  ws?: object[];
  identifier?: string;
  identifierAvailable?: boolean;
}
export interface TernaryExpr {
  ws: object[];
  position: object;
  id: string;
  thenExpression: Literal;
  kind: string;
  elseExpression: Literal;
  condition: BinaryExpr | BracedTupleExpr;
  symbolType?: string[];
}
export interface PatternClause {
  ws: object[];
  position: object;
  id: string;
  patternStreamingNode: PatternStreamingInput;
  forAllEvents: boolean;
  kind: string;
}
export interface PatternStreamingInput {
  ws?: object[];
  position: object;
  id: string;
  followedBy: boolean;
  forWithNot: boolean;
  orOnly: boolean;
  andWithNot: boolean;
  patternStreamingEdgeInputs: PatternStreamingEdgeInput[];
  patternStreamingInput?: PatternStreamingInput;
  andOnly: boolean;
  commaSeparated: boolean;
  kind: string;
}
export interface PatternStreamingEdgeInput {
  ws: object[];
  position: object;
  id: string;
  aliasIdentifier: string;
  whereClause?: Where;
  kind: string;
  streamReference: SimpleVariableRef;
  expression?: IntRangeExpr;
}
export interface Break {
  ws: object[];
  position: object;
  id: string;
  kind: string;
}
export interface IntRangeExpr {
  ws: object[];
  position: object;
  id: string;
  startExpression: Literal;
  kind: string;
  isWrappedWithBracket: boolean;
}
export interface JoinStreamingInput {
  ws: object[];
  position: object;
  id: string;
  unidirectionalAfterJoin: boolean;
  onExpression: BinaryExpr;
  unidirectionalBeforeJoin: boolean;
  streamingInput: StreamingInput;
  kind: string;
  joinType: string;
}
export interface XmlAttribute {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  name: XmlQname;
  value: XmlQuotedString;
  kind: string;
  inTemplateLiteral: boolean;
}
export interface XmlQuotedString {
  position: object;
  id: string;
  symbolType: string[];
  textFragments: Literal[];
  kind: string;
}
export interface XmlCommentLiteral {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  kind: string;
  textFragments: Array<Literal | BinaryExpr>;
  inTemplateLiteral?: boolean;
  root?: boolean;
  startLiteral?: string;
  isExpression?: boolean;
}
export interface Transaction {
  ws: object[];
  position: object;
  id: string;
  onAbortFunction?: SimpleVariableRef;
  retryCount?: Literal;
  onRetryBody?: Block;
  onCommitFunction?: SimpleVariableRef;
  transactionBody: Block;
  kind: string;
}
export interface Abort {
  ws: object[];
  position: object;
  id: string;
  kind: string;
}
export interface Retry {
  ws: object[];
  position: object;
  id: string;
  kind: string;
}
export interface Lock {
  ws: object[];
  position: object;
  id: string;
  body: Block;
  kind: string;
}
export interface FiniteTypeNode {
  ws: object[];
  id: string;
  symbolType: string[];
  valueSet: Literal[];
  grouped: boolean;
  nullable: boolean;
  kind: string;
}
export interface TableColumn {
  ws: object[];
  position: object;
  id: string;
  name: string;
  flagSet: string[];
  kind: string;
}
export interface TableQueryExpression {
  position: object;
  id: string;
  symbolType: string[];
  tableQuery: TableQuery;
  kind: string;
  isExpression: boolean;
}
export interface TableQuery {
  ws: object[];
  position: object;
  id: string;
  selectClauseNode: SelectClause;
  streamingInput: StreamingInput;
  kind: string;
  orderByNode?: OrderBy;
  joinStreamingInput?: JoinStreamingInput;
}
export interface OrderBy {
  ws: object[];
  position: object;
  id: string;
  variables: OrderByVariable[];
  kind: string;
}
export interface OrderByVariable {
  position: object;
  id: string;
  orderByType: string;
  variableReference: SimpleVariableRef;
  kind: string;
  noVisibleType: boolean;
}
export interface Next {
  ws: object[];
  position: object;
  id: string;
  kind: string;
}
export interface XmlAttributeAccessExpr {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  expression: FieldBasedAccessExpr | IndexBasedAccessExpr | SimpleVariableRef;
  index?: Literal | SimpleVariableRef;
  kind: string;
  isExpression?: boolean;
}
export interface Xmlns {
  ws?: object[];
  position: object;
  id: string;
  symbolType?: string[];
  namespaceURI?: Literal;
  kind: string;
  prefix?: Identifier;
  global?: boolean;
  namespaceDeclaration?: Xmlns;
}
export interface XmlTextLiteral {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  textFragments: Literal[];
  kind: string;
  root: boolean;
  startLiteral: string;
  isExpression: boolean;
}
export interface XmlPiLiteral {
  ws: object[];
  position: object;
  id: string;
  symbolType: string[];
  kind: string;
  target: Literal;
  dataTextFragments: Literal[];
  root: boolean;
  startLiteral: string;
  isExpression: boolean;
}
// tslint:enable:ban-types
